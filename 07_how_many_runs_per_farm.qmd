---
title: "How many runs per farm are needed?"
format: html
editor: source
---

# Introduction

Originally, each farm was run with 5000 Monte-Carlo simulation runs. This takes quite a long time (4-5 minutes per farm and feed). But is this necessary?

```{r}
#| label: setup
#| warning: false
#| message: false

library(arrow)
library(sf)
library(dplyr)
library(tidyr)
library(terra)
library(magrittr)
library(purrr)
library(furrr)
library(future)
library(tictoc)
library(ggplot2)
library(fs)
library(conflicted)
library(stringr)
library(readxl)
library(units)
library(qs)
library(here)
library(targets)
conflicted::conflicts_prefer(dplyr::filter(), dplyr::select(), .quiet = T)

here("src") %>% 
  list.files(pattern = "\\.R$", full.names = TRUE) %>% 
  str_subset("map", negate = T) %>% 
  walk(source)

redo <- T
```

# Set up data for MC testing

Only need a small but representative sample of farms (n = 100).

```{r set-up-data}
#| code-summary: Take data from the farmrun pipeline for nrun testing

Sys.setenv(TAR_PROJECT = "project_farmruns")

# mani <- tar_manifest()

feed_params <- tar_read(reference_feed)
farm_static_data <- tar_read(farm_static_data_chunked)
farm_static_data <- split(farm_static_data, farm_static_data$farm_ID)
farm_ts_data <- tar_read(farm_ts_data_chunked)
all_params <- tar_read(all_params)

# Just use a representative sample
ts_means <- farm_ts_data %>% 
  imap(~ mutate(.x, farm_ID = as.integer(str_split_i(.y, "_", 6)))) %>% 
  lapply(function(df){
    df %>% 
      group_by(farm_ID) %>% 
      reframe(mean = mean(temp_c))
  }) %>% 
    bind_rows()

# Get a small but representative sample
samp <- ts_means %>%
  mutate(temp_bin = ntile(mean, 15)) %>%
  group_by(temp_bin) %>%
  slice_sample(n = 2) %>%
  ungroup() %>%
  pull(farm_ID)

farm_static_data <- farm_static_data[samp]
farm_ts_data <- farm_ts_data[samp]
```

```{r define-model-runs}
#| code-summary: Set up different farm runs as functions, define multisessions

# Set up parallel processing
plan(multisession, workers = parallelly::availableCores()-5)

# This is uniform
farm_run_singular <- function() {
  purrr::map2_dfr(farm_ts_data, farm_static_data, function(ts, static) {
    uni_farm_growth(
      pop_params = all_params,
      species_params = all_params,
      water_temp = ts$temp_c,
      feed_params = feed_params,
      times = c(t_start = static$t_start, t_end = static$t_end, dt = 1),
      N_pop = ts$Npop
    ) %>% 
      purrr::map_dfr(function(mat) {
        mat %>% 
          as.data.frame() %>% 
          rename(t = V1, mean = V2, sd = 0) %>% 
          mutate(
            farm_ID = as.integer(static$farm_ID),
            t = as.integer(t)
          )
      }, .id = "measure") %>% 
      mutate(measure = as.factor(measure))
  })
}

# This has the MC runs in it
farm_run_MC = function(n) {
  purrr::map2_dfr(farm_ts_data, farm_static_data, function(ts, static) {
    fg <- farm_growth(
      pop_params = all_params,
      species_params = all_params,
      water_temp = ts$temp_c,
      feed_params = feed_params,
      times = c(t_start = static$t_start, t_end = static$t_end, dt = 1),
      N_pop = ts$Npop,
      nruns = n
    )
    fg %>% 
      purrr::map_dfr(function(mat) {
        mat %>% 
          as.data.frame() %>% 
          rename(t = V1, mean = V2, sd = V3) %>% 
          mutate(
            farm_ID = as.integer(static$farm_ID),
            t = as.integer(t)
          )
      }, .id = "measure") %>% 
      mutate(measure = as.factor(measure))
  })
}
```

```{r save-nruns-5000}
#| code-summary: Run the model with 5000 nruns (default) and save

if (!file.exists(file.path(output_sens_data_path, "res_nruns_5000.qs")) | redo == T) {
  res_5000 <- farm_run_MC(5000) # Takes 4-5 minutes PER FARM
  res_5000 <- res_5000 %>% 
    mutate(nruns = as.factor(5000))

  qsave(res_5000, file.path(output_sens_data_path, "res_nruns_5000.qs"))
} else {
  res_5000 <- qread(file.path(output_sens_data_path, "res_nruns_5000.qs"))
}
```

# Test uniform farm run

First of all, how does the MC run approach using 5000 runs (the default) differ from only using a uniform fish weight/maximum ingestion?

```{r save-runs-1}
#| code-summary: Run the model with nrun = 1

if (!file.exists(file.path(output_sens_data_path, "res_nruns_1.qs")) | redo == T) {
  res_single <- farm_run_singular() %>% 
    mutate(nruns = as.factor(1), sd = 0) %>% 
    relocate(sd, .after = mean)

  qsave(res_single, file.path(output_sens_data_path, "res_nruns_1.qs"))
} else {
  res_single <- qread(file.path(output_sens_data_path, "res_nruns_1.qs"))
}
```

```{r fig-nruns-weight}
#| fig-width: 8.5
#| fig-cap: Individual weight at each timestep, when the farm has been run with 5000 Monte-Carlo runs (with a range of fish weights/maximum ingestion values) and when only mean fish weight/maximum ingestion was used.

weight_single <- res_single %>% 
  filter(measure == "weight_stat")
weight_5000 <- res_5000 %>% 
  filter(measure == "weight_stat")

ggplot(
  rbind(weight_single, weight_5000),
  aes(x = t, y = mean, ymin = mean-sd, ymax = mean+sd, colour = nruns, fill = nruns)
) +
  geom_line() +
  geom_ribbon(alpha = 0.25) +
  facet_wrap(facets = vars(farm_ID), nrow = 5) +
  theme_classic()
```

It looks like using only 1 nrun results in a gradual growing underestimation of individual weight with increasing time (@fig-1-nruns-weight-diff). 

```{r fig-1-nruns-weight-diff}
#| fig-width: 8.5

df_diff <- rbind(weight_single, weight_5000) %>% 
  select(-sd) %>% 
  pivot_wider(
    names_from = "nruns", names_prefix = "nruns_",
    values_from = mean
  ) %>% 
    mutate(nruns_diff = (nruns_1 - nruns_5000)/nruns_5000)

ggplot(df_diff, aes(x = t, y = 100*nruns_diff)) +
  geom_line() +
  facet_wrap(facets = vars(farm_ID), nrow = 5) +
  theme_classic()
```

# Try 100 nruns

```{r save-nruns-100}
#| code-summary: Run the model with 100 nruns and save

if (!file.exists(file.path(output_sens_data_path, "res_nruns_100.qs")) | redo == T) {
  res_100 <- farm_run_MC(100)
  res_100 <- res_100 %>% 
    mutate(nruns = as.factor(100))
  qsave(res_100, file.path(output_sens_data_path, "res_nruns_100.qs"))
} else {
  res_100 <- qread(file.path(output_sens_data_path, "res_nruns_100.qs"))
}
```

```{r fig-nruns-100-weight}
#| fig-width: 8.5
#| fig-cap: Individual weight at each timestep, when the farm has been run with 5000 Monte-Carlo runs (with a range of fish weights/maximum ingestion values) and when only mean fish weight/maximum ingestion was used.

weight_100 <- res_100 %>% 
  filter(measure == "weight_stat")
weight_5000 <- res_5000 %>% 
  filter(measure == "weight_stat")

ggplot(
  rbind(weight_100, weight_5000),
  aes(x = t, y = mean, ymin = mean-sd, ymax = mean+sd, colour = nruns, fill = nruns)
) +
  geom_line() +
  geom_ribbon(alpha = 0.25) +
  facet_wrap(facets = vars(farm_ID), nrow = 5) +
  theme_classic()
```

Using 100 nruns instead of just one has eliminated the very obvious systematic underestimation of the error gap. The greatest difference is ~6% of the weight from the original 5000 nruns.

```{r fig-nruns-weight-100-diff}
#| fig-width: 8.5

df_diff <- rbind(weight_100, weight_5000) %>% 
  select(-sd) %>% 
  pivot_wider(
    names_from = "nruns", names_prefix = "nruns_",
    values_from = mean
  ) %>% 
    mutate(nruns_diff = (nruns_100 - nruns_5000)/nruns_5000)

ggplot(df_diff, aes(x = t, y = 100*nruns_diff)) +
  geom_line() +
  facet_wrap(facets = vars(farm_ID), nrow = 5) +
  theme_classic()
```

# Try 250 nruns

```{r save-nruns-250}
#| code-summary: Run the model with 250 nruns and save

if (!file.exists(file.path(output_sens_data_path, "res_nruns_250.qs")) | redo == T) {
  res_250 <- farm_run_MC(250)
  res_250 <- res_250 %>% 
    mutate(nruns = as.factor(250))
  qsave(res_250, file.path(output_sens_data_path, "res_nruns_250.qs"))
} else {
  res_250 <- qread(file.path(output_sens_data_path, "res_nruns_250.qs"))
}
```

```{r fig-nruns-250-weight}
#| fig-width: 8.5
#| fig-cap: Individual weight at each timestep, when the farm has been run with 5000 Monte-Carlo runs (with a range of fish weights/maximum ingestion values) and when only mean fish weight/maximum ingestion was used.

weight_250 <- res_250 %>% 
  filter(measure == "weight_stat")
weight_5000 <- res_5000 %>% 
  filter(measure == "weight_stat")

ggplot(
  rbind(weight_250, weight_5000),
  aes(x = t, y = mean, ymin = mean-sd, ymax = mean+sd, colour = nruns, fill = nruns)
) +
  geom_line() +
  geom_ribbon(alpha = 0.25) +
  facet_wrap(facets = vars(farm_ID), nrow = 5) +
  theme_classic()
```

The error is slightly smaller now (~4%, @fig-nruns-weight-250-diff) but I'll aim to get it to ~2% before I call it good.

```{r fig-nruns-weight-250-diff}
#| fig-width: 8.5

df_diff <- rbind(weight_250, weight_5000) %>% 
  select(-sd) %>% 
  pivot_wider(
    names_from = "nruns", names_prefix = "nruns_",
    values_from = mean
  ) %>% 
    mutate(nruns_diff = (nruns_250 - nruns_5000)/nruns_5000)

ggplot(df_diff, aes(x = t, y = 100*nruns_diff)) +
  geom_line() +
  facet_wrap(facets = vars(farm_ID), nrow = 5) +
  theme_classic()
```

# Try 500 nruns

```{r save-nruns-500}
#| code-summary: Run the model with 500 nruns and save

if (!file.exists(file.path(output_sens_data_path, "res_nruns_500.qs")) | redo == T) {
  res_500 <- farm_run_MC(500)
  res_500 <- res_500 %>% 
    mutate(nruns = as.factor(500))
  qsave(res_500, file.path(output_sens_data_path, "res_nruns_500.qs"))
} else {
  res_500 <- qread(file.path(output_sens_data_path, "res_nruns_500.qs"))
}
```

```{r fig-nruns-500-weight}
#| fig-width: 8.5
#| fig-cap: Individual weight at each timestep, when the farm has been run with 5000 Monte-Carlo runs (with a range of fish weights/maximum ingestion values) and when only mean fish weight/maximum ingestion was used.

weight_500 <- res_500 %>% 
  filter(measure == "weight_stat")
weight_5000 <- res_5000 %>% 
  filter(measure == "weight_stat")

ggplot(
  rbind(weight_500, weight_5000),
  aes(x = t, y = mean, ymin = mean-sd, ymax = mean+sd, colour = nruns, fill = nruns)
) +
  geom_line() +
  geom_ribbon(alpha = 0.25) +
  facet_wrap(facets = vars(farm_ID), nrow = 5) +
  theme_classic()
```

This number of runs results in a total mis-estimation of max 2% (@fig-nruns-weight-500-diff), so I'd called that good enough.

```{r fig-nruns-weight-500-diff}
#| fig-width: 8.5

df_diff <- rbind(weight_500, weight_5000) %>% 
  select(-sd) %>% 
  pivot_wider(
    names_from = "nruns", names_prefix = "nruns_",
    values_from = mean
  ) %>% 
    mutate(nruns_diff = (nruns_500 - nruns_5000)/nruns_5000)

ggplot(df_diff, aes(x = t, y = 100*nruns_diff)) +
  geom_line() +
  facet_wrap(facets = vars(farm_ID), nrow = 5) +
  theme_classic()
```


```{r}

```