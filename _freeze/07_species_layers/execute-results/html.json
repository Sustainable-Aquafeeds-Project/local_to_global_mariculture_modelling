{
  "hash": "6573c2fee56fd0243bc359e11fccc705",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"07_species_layers\"\neditor: source\n---\n\n\n\n\n\n# Base rasters for resolution\n\nCreate a blank raster with enough resolution to get farms in there (100m)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_rast <- rast(res = 0.1/111.32, extent = ext(-180, 180, -90, 90), crs = \"EPSG:4326\")\n\ninset_boxes <- list(\n  CAN1 = c(-132, -122, 47.75, 54.25),\n  CAN2 = c(-70, -54, 43, 48.5),\n  EUR = c(-26, 30, 51, 72),\n  CHI = c(-77.5, -62.5, -56, -25),\n  AUS = c(144, 149.5, -44, -39.75)\n)\n\ninset_rasters <- list(\n  CAN1 = crop(base_rast, ext(inset_boxes[[\"CAN1\"]])),\n  CAN2 = crop(base_rast, ext(inset_boxes[[\"CAN2\"]])),\n  EUR  = crop(base_rast, ext(inset_boxes[[\"EUR\"]])),\n  CHI  = crop(base_rast, ext(inset_boxes[[\"CHI\"]])),\n  AUS  = crop(base_rast, ext(inset_boxes[[\"AUS\"]]))\n)\n```\n:::\n\n\n\n# Farm circles\n\nGive each farm a basic \"circle of influence\" - currently set at 2km. Possibility to reduce this/create a dispersion pattern later. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfarm_circles_file <- file.path(output_farm_data_path, \"farm_circles_2km.tif\")\n\nfarm_circles_rast <- if (!file.exists(farm_circles_file) | overwrite) {\n  # Read in farm locations (sf objects)\n  farm_locs <- file.path(output_farm_data_path, \"farm_geometry.qs\") %>% \n    qread()\n  \n  # Create circular buffers for crude (~1km) area of impact and merge overlapping areas\n  farm_circles <- st_sf(farm_id = farm_locs$farm_id, geometry = farm_locs$geometry) %>%\n    st_transform(crs = crs(base_rast)) %>%  # transform to match background N projection\n    st_buffer(dist = 2000) %>%  # 2 km radius circles - for maximum possible impact (temporary for testing method)\n    st_union() %>%  # merge overlapping polygons\n    st_sf() %>%  # convert back to sf object\n    mutate(id = 1)  # add single ID for rasterization\n  \n  farm_rast <- rasterize(vect(farm_circles), base_rast, field = \"id\") # this takes a long time because the base raster is so fine\n  writeRaster(farm_rast, farm_circles_file, overwrite = T)\n  farm_rast\n} else {\n  rast(farm_circles_file)\n}\n```\n:::\n\n\n\nAlso save the individual areas of farm clusters so later species-overlaying is a bit faster.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfa_list <- file.path(output_farm_data_path, sprintf(\"farm_circles_2km_inset_%s.tif\", 1:5))\nfor (i in 1:5) {\n  if (!file.exists(fa_list[i]) | overwrite) {\n    fa_rast <- crop(farm_circles_rast, inset_rasters[[i]])\n    writeRaster(fa_rast, fa_list[i])\n  }\n}\n\n# Testing out different resolutions for the farm_circles\nfa_rast_100m <- rast(fa_list[4])\nfa_rast_250m <- aggregate(fa_rast_100m, fact = 2.5, fun = \"modal\")\nfa_rast_500m <- aggregate(fa_rast_100m, fact = 5, fun = \"modal\")\nfa_rast_1000m <- aggregate(fa_rast_100m, fact = 10, fun = \"modal\")\n\nfa_ggplot <- function(df) {\n  ggplot() +\n    geom_spatraster(data = df, mapping = aes(fill = id), na.rm = T) +\n    scale_fill_viridis_c(na.value = \"transparent\") +\n    coord_sf(expand = FALSE) +\n    theme_void()\n}\n\nplot_grid(\n  fa_ggplot(fa_rast_100m),\n  fa_ggplot(fa_rast_250m),\n  fa_ggplot(fa_rast_500m),\n  fa_ggplot(fa_rast_1000m),\n  ncol = 2\n)\n```\n:::\n\n\n\n# Species vulnerabilities\n\nUsing trait-based vulnerability data downloaded from @ohara_code_2021 [@butt_trait-based_2022].\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvulnerabilities <- file.path(input_spec_layers_path, \"spp_gp_vuln_w_distribution.csv\") %>% \n  read.csv() %>% \n  mutate(spp_gp = str_to_sentence(spp_gp)) %>% \n  filter(stressor == \"eutrophication_nutrient_pollution\") %>% \n  mutate(taxon = as.factor(taxon)) %>% \n  mutate(spp_gp = str_remove(spp_gp, \"\\\\s*\\\\([^)]*\\\\)\")) %>%  # remove non-accepted names in parentheses\n  filter(exposure_mod != 0) %>% \n  select(-contains(\"sd\"), -stressor)\n\nggplot(vulnerabilities, aes(x = taxon, y = vuln, fill = taxon)) +\n  geom_boxplot() +\n  coord_flip()\n```\n:::\n\n\n\n## Species ranges\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# download_db(force = FALSE) # This step downloads the Aquamaps database, ~ 2GB. Only need to do this once\ndefault_db(\"sqlite\") # Need this step in order to set up to query database\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvuln_am_keys <- split(vulnerabilities, vulnerabilities$spp_gp) %>% \n  lapply(function(vdf) {\n    keys <- am_search_fuzzy(vdf$spp_gp) %>% \n      mutate(key = as.character(key),\n             terms = as.character(terms),\n             spp_gp = vdf$spp_gp,\n             genus_species = str_extract(terms, \"^\\\\S+\\\\s+\\\\S+\"))\n    merge(vdf, keys, by = \"spp_gp\")\n  }) %>% \n  bind_rows() %>% \n  # The vulnerabilities are applied at different levels depending on data available, which can affect distribution lookups\n  mutate(\n    match_level = case_when(\n      genus_species == spp_gp ~ \"species\",\n      str_detect(str_to_lower(genus_species), str_to_lower(spp_gp)) ~ \"genus\",\n      str_detect(spp_gp, \"ae$\") ~ \"family\",\n      str_detect(str_to_lower(terms), str_to_lower(spp_gp)) & !str_detect(str_to_lower(genus_species), str_to_lower(spp_gp)) ~ \"common\",\n      str_detect(str_to_lower(terms), str_to_lower(spp_gp)) ~ \"other_taxon\",\n      T ~ NA\n    ),\n    match_level = factor(match_level, levels = c(\"species\", \"genus\", \"family\", \"other_taxon\", \"common\"))\n  ) %>% \n  arrange(match_level) %>% \n  # Keep only one key (aquamaps dataset) per species, but there may be multiple vulnerabilities\n  distinct(key, .keep_all = T)\n```\n:::\n\n\n\n### Get species rasters\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_keys <- vuln_am_keys$key\nfor (i in seq_along(all_keys)) {\n  ras <- am_raster(key = all_keys[i]) %>% rast()\n  names(ras) <- \"probability\"\n  writeRaster(ras, file.path(input_aquamaps_path, str_c(all_keys[i], \".tif\")), overwrite = T)\n}\n```\n:::\n\n\n\nConvert to Gall projection for equal area?\n\n# Calculate overlapping area\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvuln_am_keys <- vuln_am_keys %>% \n  mutate(total_species_area = NA,\n         farm_overlap_area = NA,\n         file_nm = file.path(input_aquamaps_path, str_c(key, \".tif\"))) %>% \n  select(-terms)\n\nfa_rasts <- list.files(output_farm_data_path, full.names = T, pattern = \"farm_circles_2km_inset\") %>% \n  as.list() %>% \n  lapply(function(fnm){\n    rast(fnm) %>% aggregate(fact = 10, fun = \"modal\") # use 1km resolution for speed\n  })\nfa_exts <- lapply(fa_rasts, ext) %>% unlist()\n```\n:::\n\n\n\nGet the total overlap between the farm buffer circles (1km radius) and the species range (presence/absence). The data from aquamaps gives a probability of species presence (0-1) but that is not incorporated here (yet).\n\nI tried to do this in parallel but `terra` has issues with parallel processing - couldn't get it to work. But it only takes ~25 minutes (with all the speed measures taken above).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (sp in 1:nrow(vuln_am_keys)) {\n  species_range_raster <- rast(vuln_am_keys$file_nm[sp])\n  \n  # Temporary - exclude cells where probability < 0.05 and set remaining cells to 1 for presence\n  species_range_raster[species_range_raster < 0.05] <- NA \n  species_range_raster[!is.na(species_range_raster)] <- 1\n  \n  # Get total species range area\n  vuln_am_keys$total_species_area[sp] <- global(\n    cellSize(species_range_raster, unit = \"km\") * !is.na(species_range_raster), \"sum\", na.rm = TRUE\n    )$sum\n  \n  # Check species extent against farm extents to see if it's worth continuing\n  pre_check <- lapply(fa_rasts, function(ras) {\n      check1 <- !is.null(terra::intersect(ext(ras), ext(species_range_raster))) # do extents overlap?\n      if (check1) {\n        check2 <- crop(species_range_raster, ras) %>% # is any value != NA?\n          minmax() %>% as.vector() %>% is.na() %>% any() %>% isFALSE()\n      } else {check2 <- F}\n      all(check1, check2) # if any are F ~ F\n    }) %>% unlist()\n  \n  # For areas worth overlaying (passed pre-check)\n  overlap_rasts_fa <- fa_rasts[pre_check]\n  overlap_rasts_sp <- lapply(overlap_rasts_fa, function(ras) {\n      sp_rast <- crop(species_range_raster, ras)\n      sp_rast <- resample(sp_rast, ras, method = \"bilinear\")\n      overlap_mask <- !is.na(sp_rast) & !is.na(ras)\n      global(cellSize(overlap_mask, unit = \"km\") * overlap_mask, \"sum\", na.rm = TRUE)$sum\n    })\n  vuln_am_keys$farm_overlap_area[sp] <- overlap_rasts_sp %>% unlist() %>% sum()\n  \n  if (sp %in% as.integer(seq(0,nrow(vuln_am_keys), length.out = 21))) {\n    print(paste0(sp, \" of \", nrow(vuln_am_keys), \" done, \",\n                 round(100*sp/nrow(vuln_am_keys),0), \"% finished at \", Sys.time()))\n  }\n}\n\nvuln_am_keys <- vuln_am_keys %>% \n  mutate(overlap_percent = 100*farm_overlap_area/total_species_area) \n\nqsave(vuln_am_keys, file.path(impacts_path, \"vulnerability_areaoverlap_allspecies.qs\"))\n\nvuln_am_keys <- vuln_am_keys %>% \n  filter(overlap_percent > 0) %>% \n  arrange(-overlap_percent)\n\nqsave(vuln_am_keys, file.path(impacts_path, \"vulnerability_areaoverlap_nonzero.qs\"))\n```\n:::\n\n\n\nIn this very crude and liberal estimation, the maximum exposure of any species to farm nutrient inputs was ~1.9%. \n\n```{roverlap-plot}\nxbreaks <- c(min(vuln_am_keys$overlap_percent/100), max(vuln_am_keys$overlap_percent/100)) %>% log()\nxbreaks <- seq(xbreaks[1], xbreaks[2], length.out = 5)\nxlabels <- exp(xbreaks)\n\nscientific_10 = function(x) {\n  ifelse(\n    x==0, \"0\",\n    parse(text = sub(\"e[+]?\", \" %*% 10^\", scales::scientific_format()(x)))\n  )\n} \n\nggplot(vuln_am_keys, aes(x = log(overlap_percent/100), y = vuln, colour = taxon)) +\n  geom_point() +\n  theme_classic() +\n  scale_x_continuous(breaks = xbreaks, labels = scientific_10(xlabels)) +\n  labs(y = \"Vulnerability\", x = \"% overlap with species range\")\n```\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}