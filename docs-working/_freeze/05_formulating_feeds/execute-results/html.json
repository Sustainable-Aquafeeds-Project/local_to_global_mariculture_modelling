{
  "hash": "8e3fd870cdd73667474661e7a71d4bea",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Formulating experimental feeds\"\nauthor: Tormey Reimer\ndate: today\neditor: source\n---\n\n# Introduction\n\nThe purpose of this markdown is to formulate all the feeds that will be used in the analysis. These feeds are:\n- marine_dominant: a \"past\" salmonid diet where most protein is sourced from marine-based ingredients.\n- plant_dominant: a \"current\" salmonid diet where most protein is sourced from land-based ingredients.\n- novel_inclusive_2: a potential future salmonid diet which includes some novel ingredients. This formulation uses maximal digestibility values.\n- novel_inclusive_1: a potential future salmonid diet which includes some novel ingredients. This formulation uses the same formulation as novel_inclusive_2, but with minimal digestibility values.\n\n\n\n# Import ingredients\n\nThere is no check or correction here to ensure that protein + lipid + ash + carb = 1 in the incoming ingredient data. This was checked manually prior to import. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Get ingredient details (PLC composition, digestibility)\"}\ningreds <- file.path(input_feed_profile_path, \"all_ingredients.xlsx\") %>% \n  read_excel(sheet = \"all_ingredients\") %>% \n  mutate(ingredient = as.factor(ingredient))\n\ningred_nms <- levels(ingreds$ingredient)\n```\n:::\n\n\n# Import feeds\n\nUnlike ingredients, the feeds do not need to be checked for sum = 1 prior to import. That check is done here.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Feed compositions\"}\nfeed_inputs <- file.path(input_feed_profile_path, \"all_feeds.xlsx\") %>% \n  read_excel(sheet = \"all_feeds\")\n  \nfeed_inputs <- feed_inputs %>% \n  pivot_longer(names_to = \"feed\", values_to = \"proportion\", cols = !contains(c(\"ingredient\", \"category\"))) %>% \n  mutate(\n    feed = as.factor(feed),\n    ingredient = as.factor(ingredient),\n    proportion = case_when(is.na(proportion) ~ 0, T ~ proportion)\n  ) %>% \n  left_join(ingreds, by = \"ingredient\") %>% \n  select(-prop_P, -P_digestibility)\n```\n:::\n\n\nInclude the range of digestibility values so that feeds can be sampled (if required) within the targets pipeline.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Novel feeds use the minimum and maximum digestibility values\"}\nfeed_inputs <- feed_inputs %>% \n  rename(\n    protein_digestibility = mean_protein_digestibility,\n    carb_digestibility = mean_carb_digestibility,\n    lipid_digestibility = mean_lipid_digestibility\n  )\n\nfeed_types <- levels(feed_inputs$feed)\n```\n:::\n\n\nCheck that ingredient proportions sum to 1.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Composition proportions\"}\nfeed_inputs <- feed_inputs %>% \n  filter(!is.na(proportion) & proportion != 0) %>% \n  group_by(feed) %>% \n  mutate(\n    sum = sum(proportion),\n    proportion = proportion/sum\n  ) %>% \n  ungroup() %>% \n  select(-sum, -ash)\n```\n:::\n\n\nThe following chunk allows as many ingredients and feeds to be added to the incoming data as needed, it will still be formatted into a form that the `targets` pipelines can use. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Format feeds as lists to feed into targets\"}\nfeed_types <- levels(feed_inputs$feed)\n\nfeed_params <- purrr::map(feed_types, function(ft) {\n  # Filter by specified feed\n  df <- feed_inputs %>% filter(feed == ft) \n\n  list(\n    Proteins = df %>% \n      select(ingredient, proportion, contains(\"protein\")) %>% \n      rename(\n        macro = protein, \n        digest = protein_digestibility,\n        min_digest = min_protein_digestibility,\n        max_digest = max_protein_digestibility\n      ),\n    Carbohydrates = df %>% \n      select(ingredient, proportion, contains(\"carb\")) %>% \n      rename(\n        macro = carb, \n        digest = carb_digestibility,\n        min_digest = min_carb_digestibility,\n        max_digest = max_carb_digestibility\n      ),\n    Lipids = df %>% \n      select(ingredient, proportion, contains(\"lipid\")) %>% \n      rename(\n        macro = lipid, \n        digest = lipid_digestibility,\n        min_digest = min_lipid_digestibility,\n        max_digest = max_lipid_digestibility\n      )\n  )\n}) %>% \n  setNames(feed_types)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqsave(feed_params, file.path(output_species_data_path, \"feed_params.qs\"))\n```\n:::\n\n\n# Similarity\n\nFor later - how similar are the diets?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfeed_simil <- feed_inputs %>% \n  select(ingredient, feed, proportion) %>% \n  as.data.frame() %>% \n  pivot_wider(\n    names_from = feed,\n    values_from = proportion,\n    id_cols = ingredient,\n    values_fn = as.numeric\n  ) %>% \n  mutate(\n    diff_PD_MD = abs(marine_dominant - plant_dominant),\n    diff_PD_NI = abs(novel_inclusive - plant_dominant)\n  )\n\n1 - sum(feed_simil$diff_PD_MD, na.rm = T)\n1 - sum(feed_simil$diff_PD_NI, na.rm = T)\n```\n:::\n\n\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}